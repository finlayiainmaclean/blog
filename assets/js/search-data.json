{
  
    
        "post0": {
            "title": "Differential expression analysis without having to use R (much)",
            "content": "A lot of bioinformatics code ends up being a Frankenstein mismatch of R and Python code stiched together. The rpy2 package is a nice middle ground, allowing R objects and code to be run directly from Python objects. . Almost everyone I&#39;ve met uses DESeq2 for differential expression analysis of RNAseq data. In this notebook we&#39;ll perform a toy example of DEA using DESeq2, without having to write any code in R. . !pip install -q condacolab import condacolab condacolab.install() !conda config --add channels defaults !conda config --add channels bioconda !conda config --add channels conda-forge !mamba create -n env pandas rpy2 biopython bioconductor-deseq2 !conda activate env . Unfortunately, we still need to install R packages, which can take a long time. If you were using this regularly, it would be best to bundle this into a docker image, so you could just boot up a jupyterlab server with all of the R and Python packages already installed in your environment. . Installing using RStudio seems to be faster than running the code using R magic. No idea why. . q = &quot;&quot;&quot;if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;,dependencies=&#39;Depends&#39;, repo = &quot;http://cran.us.r-project.org&quot;,quiet = TRUE) BiocManager::install(c(&#39;DESeq2&#39;,&#39;apeglm&#39;, &#39;airway&#39;), update = FALSE, ask = FALSE)&quot;&quot;&quot; with open(&quot;setup.R&quot;, &quot;a&quot;) as file_object: for row in q.split(&#39; n&#39;): file_object.write(row+&#39; n&#39;) !Rscript setup.R . I adapted this code for use in a colab notebook. All clever stuff is not mine. I initially tried to just pip install -e . their git repo, but I couldn&#39;t get the colab environment to recognise it. As it&#39;s only one small class, I&#39;ve just copied the code into this notebook . First, let&#39;s read in some sample RNAseq data from the airway R library. . %load_ext rpy2.ipython import pandas as pd import numpy as np . %%R -o counts -o metadata library(airway) data(airway) counts = as.data.frame(assays(airway)) metadata = as.data.frame(colData(airway)) . Looks like there are no replicates, but a few different cell types that we&#39;ll need to add as covariates to the statistical model in DESeq2. We&#39;ll perform a comparison on pre/posttreatment dex (presume dexamethasone?). . metadata . SampleName cell dex albut Run avgLength Experiment Sample BioSample . SRR1039508 GSM1275862 | N61311 | untrt | untrt | SRR1039508 | 126 | SRX384345 | SRS508568 | SAMN02422669 | . SRR1039509 GSM1275863 | N61311 | trt | untrt | SRR1039509 | 126 | SRX384346 | SRS508567 | SAMN02422675 | . SRR1039512 GSM1275866 | N052611 | untrt | untrt | SRR1039512 | 126 | SRX384349 | SRS508571 | SAMN02422678 | . SRR1039513 GSM1275867 | N052611 | trt | untrt | SRR1039513 | 87 | SRX384350 | SRS508572 | SAMN02422670 | . SRR1039516 GSM1275870 | N080611 | untrt | untrt | SRR1039516 | 120 | SRX384353 | SRS508575 | SAMN02422682 | . SRR1039517 GSM1275871 | N080611 | trt | untrt | SRR1039517 | 126 | SRX384354 | SRS508576 | SAMN02422673 | . SRR1039520 GSM1275874 | N061011 | untrt | untrt | SRR1039520 | 101 | SRX384357 | SRS508579 | SAMN02422683 | . SRR1039521 GSM1275875 | N061011 | trt | untrt | SRR1039521 | 98 | SRX384358 | SRS508580 | SAMN02422677 | . R objects can be handled in Python using rpy2.robjects. Translation of dataframes between languages is handled by robjects.conversion. . import pandas as pd import rpy2.robjects as robjects from rpy2.robjects import pandas2ri, numpy2ri, Formula from rpy2.robjects.conversion import localconverter from rpy2.robjects.packages import importr import numpy as np import logging logging.basicConfig(level = logging.INFO) logger = logging.getLogger(&#39;DESeq2&#39;) deseq = importr(&#39;DESeq2&#39;) &#39;&#39;&#39; Adopted from: https://stackoverflow.com/questions/41821100/running-deseq2-through-rpy2 &#39;&#39;&#39; to_dataframe = robjects.r(&#39;function(x) data.frame(x)&#39;) class py_DESeq2: &#39;&#39;&#39; DESeq2 object through rpy2 Args: count_matrix (pd.DataFrame): should be a pandas dataframe with each column as count, and a id column for gene id design_matrix (pd.DataFrame): an design matrix in the form of pandas dataframe, see DESeq2 manual, samplenames as rownames design_formula (str): see DESeq2 manual, example: &quot;~ treatment&quot;&quot; gene_column (str): column name of gene id columns, example &quot;id&quot; count_matrix example:: id sampleA sampleB geneA 5 1 geneB 4 5 geneC 1 2 Design matrix example:: treatment sampleA1 A sampleA2 A sampleB1 B sampleB2 B &#39;&#39;&#39; def __init__(self, count_matrix, design_matrix, design_formula, gene_column=&#39;id&#39;): try: assert gene_column in count_matrix.columns, &#39;Wrong gene id column name&#39; gene_id = count_matrix[gene_column] except AttributeError: sys.exit(&#39;Wrong Pandas dataframe?&#39;) self.dds = None self.result = None self.deseq_result = None self.resLFC = None self.comparison = None self.normalized_count_df = None self.gene_column = gene_column self.gene_id = count_matrix[self.gene_column] self.samplenames = count_matrix.columns[count_matrix.columns != self.gene_column] with localconverter(robjects.default_converter + pandas2ri.converter): self.count_matrix = robjects.conversion.py2rpy(count_matrix.set_index(self.gene_column)) self.design_matrix = robjects.conversion.py2rpy(design_matrix) self.design_formula = Formula(design_formula) self.dds = deseq.DESeqDataSetFromMatrix(countData=self.count_matrix, colData=self.design_matrix, design=self.design_formula) def run_deseq(self, **kwargs): &quot;&quot;&quot; actually running deseq2 Args: **kwargs: Any keyword arguments for DESeq From DESeq2 manual: DESeq( object, test = c(&quot;Wald&quot;, &quot;LRT&quot;), fitType = c(&quot;parametric&quot;, &quot;local&quot;, &quot;mean&quot;, &quot;glmGamPoi&quot;), sfType = c(&quot;ratio&quot;, &quot;poscounts&quot;, &quot;iterate&quot;), betaPrior, full = design(object), reduced, quiet = FALSE, minReplicatesForReplace = 7, modelMatrixType, useT = FALSE, minmu = if (fitType == &quot;glmGamPoi&quot;) 1e-06 else 0.5, parallel = FALSE, BPPARAM = bpparam() ) &quot;&quot;&quot; self.dds = deseq.DESeq(self.dds, **kwargs) self.comparison = list(deseq.resultsNames(self.dds)) def get_deseq_result(self, contrast=None, **kwargs): &#39;&#39;&#39; DESeq2: result(dds, contrast) making a dds.deseq_result pandas dataframe &#39;&#39;&#39; if contrast: if len(contrast)==3: R_contrast = robjects.vectors.StrVector(np.array(contrast)) else: if len(contrast) != 2: raise ValueError(&#39;Contrast must be length of 3 or 2&#39;) R_contrast = robjects.ListVector({None:con for con in contrast}) logger.info(&#39;Using contrast: %s&#39; %contrast) self.result = deseq.results(self.dds, contrast = R_contrast, **kwargs) # Robject else: self.result = deseq.results(self.dds, **kwargs) # R object self.deseq_result = to_dataframe(self.result) # R dataframe with localconverter(robjects.default_converter + pandas2ri.converter): self.deseq_result = robjects.conversion.rpy2py(self.deseq_result) ## back to pandas dataframe self.deseq_result[self.gene_column] = self.gene_id.values def normalized_count(self): &#39;&#39;&#39; Returns: pd.DataFrame: a dataframe in the format of DESeq2::Counts(dds, normalized=TRUE) in R &#39;&#39;&#39; normalized_count_matrix = deseq.counts_DESeqDataSet(self.dds, normalized=True) normalized_count_matrix = to_dataframe(normalized_count_matrix) # switch back to python with localconverter(robjects.default_converter + pandas2ri.converter): self.normalized_count_df = robjects.conversion.rpy2py(normalized_count_matrix) self.normalized_count_df[self.gene_column] = self.gene_id.values logger.info(&#39;Normalizing counts&#39;) return self.normalized_count_df def lfcShrink(self, coef, method = &#39;apeglm&#39;): &#39;&#39;&#39; Perform LFC shrinkage on the DDS object see: http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html Be sure to check dds.comparison to see which coef (1-base) to use Args: coef (int): 1-based index for selecting which of dds.comparison to show method (str): DESeq2 lfcshrink method (&quot;apeglm&quot;, &quot;ashr&quot;, &quot;normal&quot;) Returns: pandas.DataFrame: a deseq2 result table &#39;&#39;&#39; lfc = deseq.lfcShrink(self.dds, res = self.result, coef = coef, type = method) with localconverter(robjects.default_converter + pandas2ri.converter): lfc = robjects.conversion.rpy2py(to_dataframe( lfc)) return lfc .reset_index() .rename(columns = {&#39;index&#39;:self.gene_column}) . The contrast list is so bizarre. The first entry is the column name of the samples, and the second and third are the samples you want to compare. . contrast = [&#39;dex&#39;,&#39;untrt&#39;,&#39;trt&#39;] dds = py_DESeq2(count_matrix = counts.reset_index().drop(columns=[&#39;group&#39;,&#39;group_name&#39;]), design_matrix = metadata, design_formula = &#39;~ cell + dex&#39;, gene_column = &#39;index&#39;) # &lt;- telling DESeq2 this should be the gene ID column dds.run_deseq() dds.get_deseq_result(contrast = contrast) res = dds.deseq_result print(dds.comparison) # show coefficients for GLM ix = [ix for ix,i in enumerate(dds.comparison) if i == f&#39;{contrast[0]}_{contrast[1]}_vs_{contrast[2]}&#39;][0]+1 # show coefficients for GLM lfc_res = dds.lfcShrink(coef=ix, method=&#39;apeglm&#39;).dropna() lfc_res.head() . WARNING:rpy2.rinterface_lib.callbacks:R[write to console]: estimating size factors WARNING:rpy2.rinterface_lib.callbacks:R[write to console]: estimating dispersions WARNING:rpy2.rinterface_lib.callbacks:R[write to console]: gene-wise dispersion estimates WARNING:rpy2.rinterface_lib.callbacks:R[write to console]: mean-dispersion relationship WARNING:rpy2.rinterface_lib.callbacks:R[write to console]: final dispersion estimates WARNING:rpy2.rinterface_lib.callbacks:R[write to console]: fitting model and testing INFO:DESeq2:Using contrast: [&#39;dex&#39;, &#39;untrt&#39;, &#39;trt&#39;] . [&#39;Intercept&#39;, &#39;cell_N061011_vs_N052611&#39;, &#39;cell_N080611_vs_N052611&#39;, &#39;cell_N61311_vs_N052611&#39;, &#39;dex_untrt_vs_trt&#39;] . WARNING:rpy2.rinterface_lib.callbacks:R[write to console]: using &#39;apeglm&#39; for LFC shrinkage. If used in published research, please cite: Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for sequence count data: removing the noise and preserving large differences. Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895 INFO:numexpr.utils:NumExpr defaulting to 2 threads. . index baseMean log2FoldChange lfcSE pvalue padj . 0 ENSG00000000003 | 708.602170 | 0.358811 | 0.100045 | 0.000152 | 0.001284 | . 2 ENSG00000000419 | 520.297901 | -0.185996 | 0.108172 | 0.065337 | 0.196546 | . 3 ENSG00000000457 | 237.163037 | -0.031352 | 0.130280 | 0.791506 | 0.911459 | . 4 ENSG00000000460 | 57.932633 | 0.047518 | 0.212344 | 0.758802 | 0.895033 | . 6 ENSG00000000971 | 5817.352868 | -0.408335 | 0.088267 | 0.000001 | 0.000018 | . This study has a lot of DEGs, so let&#39;s set an FDR threshold of 0.01, and LFC of 2. . degs = lfc_res[(lfc_res.padj&lt;0.01)&amp; (abs(lfc_res.log2FoldChange)&gt;2)] len(degs) . 206 . We can also generate the normalized counts and check we have a binomial distribution. . import seaborn as sns df_norm = dds.normalized_count() ex = np.log10(df_norm[&#39;SRR1039508&#39;]+1e-9) sns.distplot(ex[ex&gt;-5]) . INFO:DESeq2:Normalizing counts /usr/local/lib/python3.7/dist-packages/seaborn/distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms). warnings.warn(msg, FutureWarning) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f92e9e875d0&gt; . We can perform a sanity-check, running an over-representation analysis on the DEGs between the pre-treatment and post-treatment for dexamethasone. It seems pretty reasonable as dex is an anti-inflammatory steroid molecule that stimulates both osteogenic and adipogenic differentiation in a cell. . .",
            "url": "https://finlayiainmaclean.github.io/blog/useful_resources/2021/10/21/deseq2.html",
            "relUrl": "/useful_resources/2021/10/21/deseq2.html",
            "date": " • Oct 21, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Downloading, processing and classifying RNA-seq gene expression",
            "content": "This post shows how to use Guassian mixture models for data transformation of RNAseq expression. But first, we need some raw gene expression data. . Holy macaroni, what did we do before Nextflow? In the past, I&#39;ve hacked together a RNAseq pipeline of FastQC-&gt;TrimGalore-&gt;FastQC-&gt;Salmon-&gt;A few python plots for QC. Nextflow&#39;s RNAseq pipeline is so much more comprehensive - see the screengrab from their git repo. Let&#39;s install Nextflow. It seems to work best in docker, so do this outside of colab. . . !wget -qO- https://get.nextflow.io | bash !chmod +x nextflow . Download FASTQ files for one run (SRR4457124) of a study sequencing colorectal cancer biospecimens. . !echo &quot;SRR4457124&quot; &gt;&gt; ids.txt !nextflow run nf-core/fetchngs --input ids.txt -profile docker . Create samplesheet (in our case just two pairsed FASTQ files for one run), and run the RNAseq pipeline. . !wget -L https://raw.githubusercontent.com/nf-core/rnaseq/master/bin/fastq_dir_to_samplesheet.py ./fastq_dir_to_samplesheet.py &lt;FASTQ_DIR&gt; samplesheet.csv --strandedness reverse !nextflow run nf-core/rnaseq --input samplesheet.csv --genome GRCh37 -profile docker . Back in colab, import the gene level psuedocounts from our run, log2 transform, and remove the spike at 0 (now -30). . genes = pd.read_csv(&#39;genes.csv&#39;) ex = np.log2(genes.counts+1e-9) ex = ex[ex&gt;np.log2(1e-9)+1e-9] . Fit a 2 component Guassian mixture model, and compute the means, covariances, and weights of each Guassian distribution. We also need to compute the (approximate) point as which the two distributions intersect. . import pandas as pd import numpy as np import seaborn as sns from sklearn.mixture import GaussianMixture from sklearn.preprocessing import QuantileTransformer from matplotlib import pyplot as plt from scipy import stats def solve(m1,m2,std1,std2): a = 1/(2*std1**2) - 1/(2*std2**2) b = m2/(std2**2) - m1/(std1**2) c = m1**2 /(2*std1**2) - m2**2 / (2*std2**2) - np.log(std2/std1) return np.roots([a,b,c]) x = np.linspace(ex.min(), ex.max(), 200) qt = QuantileTransformer(n_quantiles=10, random_state=0,output_distribution=&#39;normal&#39;) gm = GaussianMixture(n_components=2, random_state=0) gm.fit(ex.values.reshape(-1, 1)) m1, m2 = gm.means_.flatten() std1, std2 = gm.covariances_.flatten() w1, w2 = gm.weights_ threshold1,threshold2 = sorted(solve(m1,m2,std1,std2)) high_threshold = (m2*0.8+x.max()*0.2)/1 . Lastly, let&#39;s discretize the expression into: . Not expressed | Low expression | Medium expression | High expression | . Let&#39;s define not expressed as anything lower than the mean of the first Guassian and low expression as between this and the intersection of Guassians. For medium expression, let&#39;s define a semi-arbitary point on the second Guassian, say 80% towards the second mean. High expression is just anything above this point. . gk = stats.gaussian_kde(ex) dd = gk.evaluate(x) plt.plot(x, dd, &#39;k-&#39;) # sns.distplot(gbm_ex) def gaussian(x, m, s, w): a = w / (s * np.sqrt(2 * np.pi)) b = -(x - m) ** 2 c = 2 * s ** 2 return a * np.exp(b / c) plt.plot(x, gaussian(x, m1, std1, w1), &quot;k--&quot;) plt.plot(x, gaussian(x, m2, std2, w2), &quot;k--&quot;) x_not_ex = np.linspace(x.min(), m1, 50) plt.fill_between(x_not_ex, gk.evaluate(x_not_ex), color=&quot;grey&quot;) x_low = np.linspace(m1, threshold1, 50) plt.fill_between(x_low, gk.evaluate(x_low), color=&quot;limegreen&quot;) x_mid = np.linspace(threshold1, high_threshold, 50) plt.fill_between(x_mid, gk.evaluate(x_mid), color=&quot;forestgreen&quot;) x_high = np.linspace(high_threshold, x.max(), 50) plt.fill_between(x_high, gk.evaluate(x_high), color=&quot;darkgreen&quot;) plt.xlabel(&#39;log2[pseudocounts]&#39;) plt.ylabel(&#39;ratio genes as expression level&#39;); .",
            "url": "https://finlayiainmaclean.github.io/blog/useful_resources/2021/10/21/_rnaseq.html",
            "relUrl": "/useful_resources/2021/10/21/_rnaseq.html",
            "date": " • Oct 21, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "What is that compound?",
            "content": "Have you ever marvelled at hard core chemists eyeballing a complex molecule and nonchalantly whittling off it&#39;s chemical name, and thought Dang! That&#39;s impressive! . Have you ever squinted at R-groups analogues, unable to name them? . Have you ever glazed fondly at the Frankenstein molecules outputted by your generative model and questioned What are you? . Then this is the cheat code for you! . There&#39;s a few resolution services that we can use to convert SMILES to IUPAC. We can wrap this functionality in a small class that will allow us to enter lists of SMILES strings of RDKit molecules. . !pip install pubchempy !pip install xmltodict !pip install -q condacolab import condacolab condacolab.install() # # condacolab.check() !mamba install -c conda-forge rdkit !pip install mols2grid . import rdkit from rdkit import Chem from rdkit.Chem import AllChem from rdkit.Chem import PandasTools from rdkit import DataStructs from rdkit.Chem.Draw import IPythonConsole from rdkit.Chem.Fingerprints import FingerprintMols from rdkit.Chem.Draw import SimilarityMaps from tqdm.notebook import tqdm import xmltodict from collections import defaultdict import mols2grid import pandas as pd import requests import pubchempy . class Resolver: def __init__(self): self.url = &quot;https://cactus.nci.nih.gov/chemical/structure/{0}/{1}&quot; def _smiles_to_iupac_cactus(self, smiles): try: response = requests.get(self.url.format(smiles, &#39;iupac_name&#39;)) response.raise_for_status() return response.text except requests.HTTPError as exception: return None def _smiles_to_iupac_pubchem(self, smiles): try: compounds = pubchempy.get_compounds(smiles, namespace=&#39;smiles&#39;) match = compounds[0] return match.iupac_name except pubchempy.BadRequestError as exception: return None def to_iupac(self, mols, method=&#39;cactus&#39;): if type(mols)!=list: mols = [mols] if type(mols[0]) == rdkit.Chem.rdchem.Mol: smiles = [Chem.MolToSmiles(mol) for mol in mols] elif type(mols[0]) == str: smiles = mols else: raise NotImplementedError(&#39;You donut - Input needs to be string or rdkit mol&#39;) if method==&#39;cactus&#39;: func = self._smiles_to_iupac_cactus elif method==&#39;pubchem&#39;: func = self._smiles_to_iupac_pubchem else: raise NotImplementedError(&#39;Muppet&#39;) return [func(smile) for smile in tqdm(smiles)] . Let&#39;s just check a few molecules, making sure we don&#39;t throw a hissy at a molecule with an invalid character. . resolver = Resolver() resolver.to_iupac([&#39;ClC(=O)C(Cl)=O&#39;,&#39;CCNB8&#39;], method=&#39;pubchem&#39;) . [&#39;oxalyl dichloride&#39;, None] . Why don&#39;t we see if we can resolve the IUPAC names for some common R-groups? We can grab Takeuchi et al&#39;s database of common R-group replacements. . !wget https://zenodo.org/record/4741973/files/top500_R_replacements.xml . And process the XML with code taken from Pat Walter&#39;s blog. . def prep_sidechain(smi, atom_map_no=1): mol = Chem.MolFromSmiles(smi) rw_mol = Chem.RWMol(mol) remove_idx = -1 for atm in rw_mol.GetAtoms(): # Find dummy atom (atomic number 0) and delete if atm.GetAtomicNum() == 0: remove_idx = atm.GetIdx() # Set neighbours of dummy atoms to 1 # for nbr in atm.GetNeighbors(): # nbr.SetAtomMapNum(atom_map_no) rw_mol.RemoveAtom(remove_idx) # Chem.SanitizeMol(rw_mol) return Chem.MolToSmiles(rw_mol) def generate_replacement_dictionary(replacement_xml_file): ifs = open(replacement_xml_file) xml = ifs.read() d = xmltodict.parse(xml) rgroups = set() replacement_dict = defaultdict() for k in d[&#39;R_replacements&#39;][&#39;center&#39;]: fl = k[&#39;first_layer&#39;] if type(fl) is not list: fl = [fl] rgroups.add(prep_sidechain(k[&#39;@SMILES&#39;])) first_layer = [rgroups.add(prep_sidechain(a[&#39;@SMILES&#39;])) for a in fl] sl = [ x for x in [a.get(&#39;second_layer&#39;) for a in fl] if x] second_layer = [] for row in sl: if type(row) is not list: row = [row] for r in row: rgroups.add(prep_sidechain(r[&#39;@SMILES&#39;])) # replacement_dict[prep_sidechain(k[&#39;@SMILES&#39;])] = [[i for i in first_layer], [i for i in second_layer]] return rgroups . Let&#39;s convert all R-groups to IUPAC names, and plot them using mol2sgrid. They do a pretty good job! . resolver = Resolver() rgroups = generate_replacement_dictionary(&#39;top500_R_replacements.xml&#39;) rgroup_names = resolver.to_iupac(list(rgroups), method=&#39;pubchem&#39;) df = pd.DataFrame(zip(list(rgroups), rgroup_names), columns = [&#39;SMILES&#39;,&#39;name&#39;]) mols2grid.display(df,fixedBondLength=25,tooltip=[&quot;name&quot;]) . .",
            "url": "https://finlayiainmaclean.github.io/blog/useful_resources/2021/10/20/iupac.html",
            "relUrl": "/useful_resources/2021/10/20/iupac.html",
            "date": " • Oct 20, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Drug repurposing using knowledge graph embeddings",
            "content": "Since Himmelstein, the grandfather of biomedical knowledge graphs, used Hetionet for drug repurposing, there have been many subsequent attempts to build both better knowledge graphs, and better link prediction models. . One of the most recent attempts at both of these tasks is the Drug Repurposing Knowledge Graph (DRKG) by a team of researchers at Amazon. . Their KG is pretty comprehensive, bringing together the aforementioned Hetionet, DrugBank, the literature-derived Global Network of Biological Relationships, STRING, IntAct and DGIdb. . . The main shortcoming of this KG, is no relationships are mapped to some universal meaning. For example, there are drug-treats-disease edges in GNBR, DrugBank, ChEMBL and Hetionet. There&#39;s also a large bunch of drug-inhibits-gene, each with their own inclusion criteria. In an ideal world, these semantically similar relations would be near eachother in the embedding space. If we look at a TSNE plot of the relationship embeddings, it seems this isn&#39;t the case - GNBR relations cluster together, and so do DGIdb relations. . !git clone https://github.com/gnn4dr/DRKG.git !wget https://dgl-data.s3-us-west-2.amazonaws.com/dataset/DRKG/drkg.tar.gz !gzip -d drkg.tar.gz !tar --get -f drkg.tar !rm -rf drkg.tar . Cloning into &#39;DRKG&#39;... remote: Enumerating objects: 291, done. remote: Counting objects: 100% (103/103), done. remote: Compressing objects: 100% (58/58), done. remote: Total 291 (delta 51), reused 80 (delta 45), pack-reused 188 Receiving objects: 100% (291/291), 19.72 MiB | 13.40 MiB/s, done. Resolving deltas: 100% (130/130), done. --2021-10-13 13:40:15-- https://dgl-data.s3-us-west-2.amazonaws.com/dataset/DRKG/drkg.tar.gz Resolving dgl-data.s3-us-west-2.amazonaws.com (dgl-data.s3-us-west-2.amazonaws.com)... 52.92.132.130 Connecting to dgl-data.s3-us-west-2.amazonaws.com (dgl-data.s3-us-west-2.amazonaws.com)|52.92.132.130|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 216650245 (207M) [application/x-tar] Saving to: ‘drkg.tar.gz’ drkg.tar.gz 100%[===================&gt;] 206.61M 34.7MB/s in 6.8s 2021-10-13 13:40:23 (30.5 MB/s) - ‘drkg.tar.gz’ saved [216650245/216650245] . import sys sys.path.append(&#39;DRKG/&#39;) import utils import csv import torch as th import numpy as np import pandas as pd from matplotlib import cm import matplotlib.pyplot as plt from sklearn.utils import check_random_state from sklearn.manifold import TSNE import torch.nn.functional as fn . entity_emb = np.load(&#39;embed/DRKG_TransE_l2_entity.npy&#39;) rel_emb = np.load(&#39;embed/DRKG_TransE_l2_relation.npy&#39;) rels = pd.read_csv(&#39;relation_glossary.tsv&#39;, sep=&#39; t&#39;) rel2id = dict(zip(rels[&#39;Relation-name&#39;],rels.index.tolist())) dataset_id = {} for rel_name, i in rel2id.items(): rel_key = rel_name.split(&#39;::&#39;)[0] if dataset_id.get(rel_key, None) is None: dataset_id[rel_key] = [] dataset_id[rel_key].append(i) X_embedded = TSNE(n_components=2).fit_transform(rel_emb).T p = cm.rainbow(int(255/2 * 1)) fig = plt.figure() ax = fig.add_subplot(111) for key, val in dataset_id.items(): val = np.asarray(val, dtype=np.long) ax.plot(X_embedded[0][val], X_embedded[1][val], &#39;.&#39;, label=key) lgd = ax.legend(bbox_to_anchor=(1.0, 1.0)) plt.savefig(&#39;relation.eps&#39;, bbox_extra_artists=(lgd,), bbox_inches=&#39;tight&#39;, format=&#39;eps&#39;) . The PostScript backend does not support transparency; partially transparent artists will be rendered opaque. The PostScript backend does not support transparency; partially transparent artists will be rendered opaque. . Let&#39;s use the various drug-treats-disease relations to find some repurposable drugs for chronic pancreatits. . # download_and_extract() # Get all drugbank IDs for all drugs !wget https://raw.githubusercontent.com/dhimmel/drugbank/gh-pages/data/drugbank.tsv drugbank = pd.read_csv(&#39;drugbank.tsv&#39;,sep=&#39; t&#39;) drugbank[&#39;drugbank_id&#39;] = &#39;Compound::&#39;+drugbank.drugbank_id drug_list = drugbank[&#39;drugbank_id&#39;].tolist() # There are 3 treatment edges from Hetionet, GNBC and DrugBank treatment = [&#39;Hetionet::CtD::Compound:Disease&#39;,&#39;GNBR::T::Compound:Disease&#39;,&#39;DRUGBANK::treats::Compound:Disease&#39;] # # MESH ID for chronic pancreatits # disease_list = [ # &#39;Disease::MESH:D019283&#39; # ] # Get drugname/disease name to entity ID mappings entity_idmap_file = &#39;embed/entities.tsv&#39; relation_idmap_file = &#39;embed/relations.tsv&#39; entity_id_map_df = pd.read_csv(entity_idmap_file,sep=&#39; t&#39;, header=None) entity_id_map = dict(zip(entity_id_map_df[1], entity_id_map_df[0])) entity_id_map_rev = dict(zip(entity_id_map_df[0], entity_id_map_df[1])) relation_map = pd.read_csv(relation_idmap_file,sep=&#39; t&#39;, header=None) relation_map = dict(zip(relation_map[0], relation_map[1])) . --2021-10-13 13:56:32-- https://raw.githubusercontent.com/dhimmel/drugbank/gh-pages/data/drugbank.tsv Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.110.133, 185.199.109.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 2889868 (2.8M) [text/plain] Saving to: ‘drugbank.tsv.14’ drugbank.tsv.14 100%[===================&gt;] 2.76M --.-KB/s in 0.02s 2021-10-13 13:56:32 (146 MB/s) - ‘drugbank.tsv.14’ saved [2889868/2889868] . def get_predictions(disease_list, drug_list): # handle the ID mapping drug_ids = [] disease_ids = [] for drug in drug_list: if drug in entity_id_map_rev: drug_ids.append(entity_id_map_rev[drug]) for disease in disease_list: disease_ids.append(entity_id_map_rev[disease]) treatment_rid = [relation_map[treat] for treat in treatment] # Get ids drug_ids = th.tensor(drug_ids).long() disease_ids = th.tensor(disease_ids).long() treatment_rid = th.tensor(treatment_rid) # Get embeddings drug_emb = th.tensor(entity_emb[drug_ids]) treatment_embs = [th.tensor(rel_emb[rid]) for rid in treatment_rid] gamma=12.0 #TransE score function def transE_l2(head, rel, tail): score = head + rel - tail return gamma - th.norm(score, p=2, dim=-1) scores_per_disease = [] dids = [] for rid in range(len(treatment_embs)): treatment_emb=treatment_embs[rid] for disease_id in disease_ids: disease_emb = entity_emb[disease_id] score = fn.logsigmoid(transE_l2(drug_emb, treatment_emb, disease_emb)) scores_per_disease.append(score) dids.append(drug_ids) scores = th.cat(scores_per_disease) dids = th.cat(dids) # sort scores in decending order idx = th.flip(th.argsort(scores), dims=[0]) scores = scores[idx].numpy() dids = dids[idx].numpy() _, unique_indices = np.unique(dids, return_index=True) topk=100 topk_indices = np.sort(unique_indices)[:topk] proposed_dids = dids[topk_indices] proposed_scores = scores[topk_indices] # Create dataframe of scores with drug metadata scores = pd.DataFrame(zip([entity_id_map[i] for i in proposed_dids], proposed_scores)) scores.columns = [&#39;drugbank_id&#39;,&#39;score&#39;] scores = scores.merge(drugbank, on=&#39;drugbank_id&#39;) return scores . Let&#39;s generate predictions for pnacreatitis, CP, and necrotizing AP, with a weighting towards CP. . cp2mesh = { &#39;Chronic pancreatitis&#39;:&#39;Disease::MESH:D050500&#39;, &#39;Pancreatitis&#39;:&#39;Disease::MESH:D010195&#39;, &#39;Acute necrotizing pancreatitis&#39;:&#39;Disease::MESH:D019283&#39;, } cp_scores = get_predictions([cp2mesh[&#39;Chronic pancreatitis&#39;]], drug_list) p_scores = get_predictions([cp2mesh[&#39;Pancreatitis&#39;]], drug_list) ap_scores = get_predictions([cp2mesh[&#39;Acute necrotizing pancreatitis&#39;]], drug_list) all_scores = cp_scores.rename(columns={&#39;score&#39;:&#39;cp_score&#39;}).merge(p_scores.rename(columns={&#39;score&#39;:&#39;p_score&#39;})[[&#39;drugbank_id&#39;,&#39;p_score&#39;]], on =&#39;drugbank_id&#39;) all_scores = all_scores.merge(ap_scores.rename(columns={&#39;score&#39;:&#39;ap_score&#39;})[[&#39;drugbank_id&#39;,&#39;ap_score&#39;]], on =&#39;drugbank_id&#39;) all_scores[&#39;final_score&#39;] = (2*all_scores[&#39;cp_score&#39;] + all_scores[&#39;p_score&#39;] + all_scores[&#39;ap_score&#39;])/4 all_scores = all_scores.sort_values(by=&#39;final_score&#39;,ascending=False).reset_index() . Inital thoughts on predictions for CP . Octreotide - Definitely the most interesting of suggestions. Octreotide is synthetic analogue of the peptide hormone somatostatin. In the pancreas, somatostatin inhibits the secretion of pancreatic hormones, including glucagon and insulin. In the gastrointestinal tract, the hormone reduces gastric secretion and the emission of gastrointestinal hormones, such as secretin and gastrin. Specific somatostatin receptors can modulate secretory response of the acinar cells via reduction of intracellular cAMP. Researchers have shown IV octreotide raises somatostatin to normal levels in plasma, and reduces circulating TNFα and IL6, reducing severity of the disease. . | Dexamethasone - Large dose dexamethasone is known to reduce severity of SAP, but the mechanism is still not fully estabished. A research group demonstrated that potential mechanisms were related to the inflammatory mediators inhibition and pancreatic acinar cell apoptosis. Another group showed upregulation of PAP genes. Both inflammation and acinar cell apopotsis are shared pathomechanisms in SAP and CP. It seems reasonable that large doses of dexamethasone could be beneficial for CP. . | Indomethacin - Whilst indomethacin is more usually used to reduce severity of pancreatitis post-ERCP surgery, there&#39;s currently a phase II trail for indomethacin for use in CP. NSAIDs (ibuprofen, indomethacin and aspirin) have been shown to reduce CFTR mRNA by roughly 50% ref. Very interesting, considering I would have assumed partially functional CFTR mutants would reduce Ca2+ transport, and thus reducing the overall expression of CFTR would have a maleficial effect on disease progression.. . | Ursodeoxycholic acid - UDCA has been shown to reduce pancreatitic enzyme secretion. This paper describes a marked decrease in trypsin levels. This paper shows a protective effect of oral UDCA on pancreatic ductal injury by reducing apoptosis. . | Acetylsalicylic acid - Aspirin has been shown to protects against acinar cells necrosis in late stage severe AP ref, and reduce gene expression of CFTR. . | Ethanol - It seems the model has conflated molecules that cause (or contribute) to CP, with molecules that can treat the disease. Ethanol is all used to induce CP in experimental models, and is a known risk factor for recurrent AP. . | Calcium - CP is a calcifying fibrotic disease predominantly caused by Ca2+ dysregulation in acinar cells driven by LoF and GoF mutations in CFTR. It&#39;s promising the model highly associated calcium with the disease. . | Glutathione - There is a known interplay between reactive oxygen species (ROS) and Ca2+ signaling, and antioxidant therapy has been suggested for CP. Enhanced generation of oxygen radicals cause changes in glutathione metabolism ref, although I&#39;m unsure if a nutriceutical administration of glutathione would affect the upstream process of ROS buildup. . | Dinoprostone - Pancreatic juice prostaglandin E2 concentrations are elevated in chronic pancreatitis. It&#39;s certainly not a treatment molecule, and much more likely to be a biomarker. . | . from pandas import option_context with option_context(&#39;display.max_colwidth&#39;, 200): display(all_scores.head(15)[[&#39;name&#39;, &#39;drugbank_id&#39;, &#39;final_score&#39;, &#39;groups&#39;,&#39;categories&#39;, &#39;description&#39;]]) . name drugbank_id final_score groups categories description . 0 Cholesterol | Compound::DB04540 | -0.281523 | experimental | NaN | The principal sterol of all higher animals, distributed in body tissues, especially the brain and spinal cord, and in animal fats and oils. [PubChem] | . 1 Octreotide | Compound::DB00104 | -0.303557 | approved|investigational | Antineoplastic Agents, Hormonal|Gastrointestinal Agents|Hormone Replacement Agents | Octreotide is the acetate salt of a cyclic octapeptide. It is a long-acting octapeptide with pharmacologic properties mimicking those of the natural hormone somatostatin. | . 2 Dexamethasone | Compound::DB01234 | -0.309098 | approved|investigational | Antineoplastic Agents, Hormonal|Anti-Inflammatory Agents|Glucocorticoids|Antiemetics | An anti-inflammatory 9-fluoro-glucocorticoid. [PubChem] | . 3 Ethanol | Compound::DB00898 | -0.318994 | approved | Anti-Infective Agents, Local|Central Nervous System Depressants|Solvents | A clear, colorless liquid rapidly absorbed from the gastrointestinal tract and distributed throughout the body. It has bactericidal activity and is used often as a topical disinfectant. It is wide... | . 4 Acetylsalicylic acid | Compound::DB00945 | -0.338402 | approved | Fibrinolytic Agents|Platelet Aggregation Inhibitors|Anti-Inflammatory Agents, Non-Steroidal|Cyclooxygenase Inhibitors|Antipyretics|Salicylates | The prototypical analgesic used in the treatment of mild to moderate pain. It has anti-inflammatory and antipyretic properties and acts as an inhibitor of cyclooxygenase which results in the inhib... | . 5 Calcium | Compound::DB01373 | -0.338819 | nutraceutical | NaN | Calcium plays a vital role in the anatomy, physiology and biochemistry of organisms and of the cell, particularly in signal transduction pathways. The skeleton acts as a major mineral storage site... | . 6 histamine dihydrochloride | Compound::DB05381 | -0.341508 | investigational | NaN | A depressor amine derived by enzymatic decarboxylation of histidine. It is a powerful stimulant of gastric secretion, a constrictor of bronchial smooth muscle, a vasodilator, and also a centrally ... | . 7 Ursodeoxycholic acid | Compound::DB01586 | -0.350238 | approved|investigational | Cholagogues and Choleretics | Ursodeoxycholic acid is an epimer of chenodeoxycholic acid (DB06777). It is a mammalian bile acid found first in the bear and is apparently either a precursor or a product of chenodeoxycholate. It... | . 8 Glutathione | Compound::DB00143 | -0.357434 | approved|nutraceutical | Dietary Supplements|Micronutrients|Supplements | A tripeptide with many roles in cells. It conjugates to drugs to make them more soluble for excretion, is a cofactor for some enzymes, is involved in protein disulfide bond rearrangement and redu... | . 9 Dinoprostone | Compound::DB00917 | -0.373270 | approved | Oxytocics|Prostaglandins | Dinoprostone is a naturally occurring prostaglandin E2 (PGE2). It has important effects in labour. It also stimulates osteoblasts to release factors which stimualtes bone resorption by osteoclasts... | . 10 Malonaldehyde | Compound::DB03057 | -0.399459 | experimental | NaN | The dialdehyde of malonic acid. [PubChem] | . 11 Indomethacin | Compound::DB00328 | -0.400192 | approved|investigational | Gout Suppressants|Anti-Inflammatory Agents, Non-Steroidal|Cyclooxygenase Inhibitors|Cardiovascular Agents|Tocolytic Agents | Indomethacin is a non-steroidal antiinflammatory agent (NSAIA) with antiinflammatory, analgesic and antipyretic activity. Its pharmacological effect is thought to be mediated through inhibition of... | . 12 Hydrocortisone | Compound::DB00741 | -0.400373 | approved | Anti-Inflammatory Agents | The main glucocorticoid secreted by the adrenal cortex. Its synthetic counterpart is used, either as an injection or topically, in the treatment of inflammation, allergy, collagen diseases, asthma... | . 13 Melatonin | Compound::DB01065 | -0.413444 | approved|nutraceutical | Antioxidants|Central Nervous System Depressants | Melatonin is a biogenic amine that is found in animals, plants and microbes. Aaron B. Lerner of Yale University is credited for naming the hormone and for defining its chemical structure in 1958. ... | . 14 Acetylcysteine | Compound::DB06151 | -0.415837 | approved | Antiviral Agents|Free Radical Scavengers|Expectorants | Acetylcysteine (also known as N-acetylcysteine or N-acetyl-L-cysteine or NAC) is primarily used as a mucolytic agent and in the management of acetaminophen poisoning. It is a derivative of cystei... | .",
            "url": "https://finlayiainmaclean.github.io/blog/useful_resources/chronic_pancreatitis/2021/10/13/drkg.html",
            "relUrl": "/useful_resources/chronic_pancreatitis/2021/10/13/drkg.html",
            "date": " • Oct 13, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Prerank GSEA for assayable biological processes",
            "content": "Whilst it often useful to use GeneOntology&#39;s biological processes to approximate the pathomechanisms of a disease, one frequently finds themself whittling through a list of enriched biological processes, trying to find a process that is actually assayable. . Fortunately, living deep within the Supplementary Material of a Nature paper, lives a curated list of processes testable through specific molecular experiments. . Let&#39;s install gseapy and download the data. . !pip install gseapy !wget https://static-content.springer.com/esm/art%3A10.1038%2Fng.3259/MediaObjects/41588_2015_BFng3259_MOESM9_ESM.xlsx !mv 41588_2015_BFng3259_MOESM9_ESM.xlsx processes.xlsx !wget https://static-content.springer.com/esm/art%3A10.1038%2Fng.3259/MediaObjects/41588_2015_BFng3259_MOESM12_ESM.xlsx !mv 41588_2015_BFng3259_MOESM12_ESM.xlsx tissue_go_mapping.xlsx !wget https://raw.githubusercontent.com/finlayiainmaclean/datadump/main/EFO_0000342-associated-diseases.csv !curl -OL https://github.com/finlayiainmaclean/datadump/blob/main/genego.tab.zip?raw=true !unzip genego.tab.zip?raw=true . import gseapy as gp import pandas as pd import numpy as np . gene2go.go.nunique(), len(processes) . (12248, 973) . There are 973 testable processes out of 12248.. Not that many.. . processes = pd.read_excel(&#39;processes.xlsx&#39;, skiprows=1) processes . GO Term Name GO Term ID . 0 abscisic_acid_mediated_signaling_pathway | GO:0009738 | . 1 abscisic_acid_metabolic_process | GO:0009687 | . 2 acetyl_coa_biosynthetic_process_from_acetate | GO:0019427 | . 3 acetylcholine_transport | GO:0015870 | . 4 actin_cytoskeleton_reorganization | GO:0031532 | . ... ... | ... | . 968 xanthophyll_metabolic_process | GO:0016122 | . 969 xenobiotic_metabolic_process | GO:0006805 | . 970 xylan_catabolic_process | GO:0045493 | . 971 xylem_and_phloem_pattern_formation | GO:0010051 | . 972 zinc_ion_transport | GO:0006829 | . 973 rows × 2 columns . The paper also mapped tissues to biological processes via first using co-occurences, and then manually curating the list. . tissue_mapping = pd.read_excel(&#39;tissue_go_mapping.xlsx&#39;, skiprows=1).set_index(&#39;BRENDA Tissue ID&#39;) bto2name = dict(zip(tissue_mapping.index, tissue_mapping.Tissue)) go2bto = {} for bto, row in tissue_mapping.drop(columns=[&#39;Tissue&#39;]).iterrows(): for go in row: if go is None: break go2bto[go] = bto . Let&#39;s run a prerank gene set enrichment analysis, using only testable biological processes. First we need to generate a geneset. . genego = pd.read_csv(&#39;genego.tab&#39;,sep=&#39; t&#39;) gene2go = [] go2name = {} for row in genego.dropna(subset=[&#39;Gene ontology (biological process)&#39;]).itertuples(): for _go in row[4].split(&#39;; &#39;): go = _go.split(&#39;[&#39;)[1].replace(&#39;]&#39;,&#39;&#39;) name = _go.split(&#39; [&#39;)[0] gene2go.append((row[2], go)) go2name[go] = name gene2go = pd.DataFrame(gene2go,columns =[&#39;gene&#39;,&#39;go&#39;]) gene2go_dict = gene2go.groupby(&#39;go&#39;)[&#39;gene&#39;].apply(list).to_dict() gene2go_testable_dict = dict([(i, gene2go_dict[i]) for i in np.intersect1d(processes[&#39;GO Term ID&#39;], gene2go.go)]) . Let&#39;s run the prerankGSEA for chronic pancreatitis genes, defined by the overall association score in OpenTargets. . cp_targets = pd.read_csv(&#39;EFO_0000342-associated-diseases.csv&#39;) cp_targets.head(5) . symbol overallAssociationScore geneticAssociations somaticMutations drugs pathwaysSystemsBiology textMining rnaExpression animalModels targetName . 0 PRSS1 | 0.834384 | 0.9183390021590296 | No data | No data | No data | 0.1838682865290527 | No data | 0.5693580106773287 | serine protease 1 | . 1 SPINK1 | 0.804783 | 0.8862311248507138 | No data | No data | No data | 0.23856390277427408 | No data | 0.3298784490540059 | serine peptidase inhibitor Kazal type 1 | . 2 CTRC | 0.740035 | 0.8910696416923192 | No data | No data | No data | 0.09941106709313025 | No data | 0.29290105828927904 | chymotrypsin C | . 3 CFTR | 0.696968 | 0.9074161629304885 | No data | No data | No data | 0.2678564156117781 | No data | 0.3978335055391351 | CF transmembrane conductance regulator | . 4 VDR | 0.369580 | No data | No data | 0.607930797611621 | No data | No data | No data | No data | vitamin D receptor | . Running the enrichment, we see calcium-mediated signaling as one of the most enriched testable processes. . pre_res = gp.prerank(rnk=cp_targets[[&#39;symbol&#39;,&#39;overallAssociationScore&#39;]].copy(), gene_sets=gene2go_testable_dict.copy(), processes=2, permutation_num=500, # reduce number to speed up testing outdir=&#39;prerank_report&#39;, format=&#39;png&#39;, seed=6) pre_res = pd.read_csv(&#39;prerank_report/gseapy.prerank.gene_sets.report.csv&#39;) pre_res[&#39;go_name&#39;] = pre_res.Term.apply(go2name.get) #Map tissue pre_res[&#39;bto&#39;] = pre_res.Term.apply(go2bto.get) pre_res[&#39;tissue_name&#39;] = pre_res.bto.apply(bto2name.get) pre_res = pre_res.sort_values(by=&#39;es&#39;,ascending=False) pre_res.head(10) . Term es nes pval fdr geneset_size matched_size genes ledge_genes go_name bto tissue_name . 0 GO:0006367 | 0.827233 | 1.431275 | 0.016000 | 0.220365 | 140 | 17 | VDR;NR3C1;CREBBP;CCN2;PGR;THRA;PPARG;E2F2;NR4A... | VDR;NR3C1;CREBBP;CCN2;PGR;THRA | transcription initiation from RNA polymerase I... | None | None | . 4 GO:0006919 | 0.742733 | 1.288945 | 0.068000 | 0.846401 | 89 | 21 | CDKN2A;NGFR;S100A9;NGF;EIF2AK3;NLRP1;BAD;PPARG... | CDKN2A;NGFR;S100A9;NGF;EIF2AK3;NLRP1;BAD | activation of cysteine-type endopeptidase acti... | None | None | . 1 GO:0016579 | 0.736472 | 1.287383 | 0.062000 | 0.577623 | 265 | 25 | CFTR;SMAD4;IL33;PTEN;TP53;BAP1;CYLD;HIF1A;MYC;... | CFTR;SMAD4 | protein deubiquitination | None | None | . 3 GO:0009749 | 0.720428 | 1.247147 | 0.122000 | 0.618023 | 62 | 18 | SLC8A1;CCN2;ILDR2;GIPR;BAD;PTEN;NEUROD1;MAFA;R... | SLC8A1;CCN2;ILDR2;GIPR;BAD;PTEN;NEUROD1;MAFA;R... | response to glucose | None | None | . 2 GO:0042593 | 0.695962 | 1.227794 | 0.060000 | 0.577756 | 104 | 37 | NGFR;PDX1;BHLHA15;GCK;INS;LEP;GCGR;WFS1;LEPR;C... | NGFR;PDX1;BHLHA15;GCK;INS;LEP;GCGR;WFS1;LEPR;C... | glucose homeostasis | None | None | . 5 GO:0019722 | 0.664942 | 1.138633 | 0.197581 | 0.944897 | 71 | 17 | CXCR2;CXCR1;BHLHA15;EIF2AK3;PDPK1;CHRM3;TRPM4;... | CXCR2;CXCR1;BHLHA15;EIF2AK3;PDPK1;CHRM3 | calcium-mediated signaling | None | None | . 6 GO:0050821 | 0.636343 | 1.112191 | 0.252505 | 0.976760 | 197 | 21 | CDKN2A;WFS1;PTEN;TP53;CDKN1A;CHEK2;SMAD3;PARK7... | CDKN2A;WFS1;PTEN;TP53;CDKN1A | protein stabilization | None | None | . 8 GO:0001666 | 0.603386 | 1.069221 | 0.310000 | 1.000000 | 157 | 36 | SMAD4;CREBBP;LEP;TLR2;CD38;NF1;HIF1A;EGR1;REG1... | SMAD4;CREBBP;LEP;TLR2;CD38 | response to hypoxia | None | None | . 9 GO:0016567 | 0.600506 | 1.053758 | 0.344000 | 1.000000 | 414 | 21 | CRBN;DDB1;RBX1;CUL4A;FEM1B;SMURF1;CUL9;SOCS1;H... | CRBN;DDB1;RBX1;CUL4A;FEM1B;SMURF1;CUL9;SOCS1 | protein ubiquitination | None | None | . 10 GO:0007204 | 0.583698 | 1.035730 | 0.380000 | 1.000000 | 149 | 25 | CXCR2;CXCR1;CD38;PKD1;GIPR;FFAR1;GHRL;CCKBR;JA... | CXCR2;CXCR1;CD38;PKD1;GIPR;FFAR1;GHRL;CCKBR;JA... | positive regulation of cytosolic calcium ion c... | None | None | . Let&#39;s take a look at the ES plot for calcium signalling. . from IPython.display import Image Image(&#39;GO:0019722.prerank.png&#39;,width=1000, height=1000) . . How does the python package gseapy compare with the R library fgsea? First let&#39;s set up R magic for colab, and install Bioconductor. . %load_ext rpy2.ipython . The rpy2.ipython extension is already loaded. To reload it, use: %reload_ext rpy2.ipython . %%R if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;fgsea&quot;) . %%R library(fgsea) library(data.table) library(ggplot2) . I&#39;m sure there is a way to convert our python dict geneset to R&#39;s ListVector, but I cba to work it out. Instead, let&#39;s create a GMT format geneset from the pandas dataframe. . df = pd.DataFrame(zip(gene2go_testable_dict.keys(), gene2go_testable_dict.values())) gene2go_testable_gmt = pd.DataFrame(df[1].tolist(), index= df[0]) gene2go_testable_gmt.to_csv(&#39;testable_processes.gmt&#39;,sep=&#39; t&#39;,header=None) %R pathways &lt;- gmtPathways(&#39;testable_processes.gmt&#39;) . ListVector with 638 elements. GO:0000054 StrVector with 412 elements. &#39;LSG1&#39; | &#39;ABCE1&#39; | &#39;EIF6&#39; | ... | &#39;&#39; | &#39;&#39; | &#39;&#39; | . | . GO:0000077 StrVector with 412 elements. &#39;RAD1&#39; | &#39;USP28&#39; | &#39;PTPN11&#39; | ... | &#39;&#39; | &#39;&#39; | &#39;&#39; | . | . GO:0000097 StrVector with 412 elements. &#39;&#39; | &#39;&#39; | &#39;&#39; | ... | &#39;&#39; | &#39;&#39; | &#39;&#39; | . | . ... ... | . GO:0090398 StrVector with 412 elements. &#39;H2AX&#39; | &#39;TBX3&#39; | &#39;SMC5&#39; | ... | &#39;&#39; | &#39;&#39; | &#39;&#39; | . | . GO:0097191 StrVector with 412 elements. &#39;SMAD3&#39; | &#39;SGPP1&#39; | &#39;PML&#39; | ... | &#39;&#39; | &#39;&#39; | &#39;&#39; | . | . GO:0097193 StrVector with 412 elements. &#39;SGPP1&#39; | &#39;MSH6&#39; | &#39;HRAS&#39; | ... | &#39;&#39; | &#39;&#39; | &#39;&#39; | . | . And the same with our scores, converting them into rnk file format. . # cp_targets[&#39;overallAssociationScore&#39;] = genetic_gp_targets[&#39;overallAssociationScore&#39;].astype(float) cp_targets[[&#39;symbol&#39;,&#39;overallAssociationScore&#39;]].to_csv(&#39;cp_targets.rnk&#39;,sep=&#39; t&#39;, index=False) . %%R ranks &lt;- read.table(&#39;cp_targets.rnk&#39;, header=TRUE, colClasses = c(&quot;character&quot;, &quot;numeric&quot;)) ranks &lt;- setNames(ranks$overallAssociationScore, ranks$symbol) . Running fgsea with (roughly) the same config as fgsea&#39;s python counterpart. . %%R -o results results &lt;- fgsea(pathways = pathways, stats = ranks, minSize = 15, maxSize = 500) old_results &lt;- results results$leadingEdge &lt;- lapply(results$leadingEdge, function(v) paste(v, collapse=&#39;,&#39;)) results &lt;- data.frame(lapply(results, unlist)) . results[&#39;go_name&#39;] = results.pathway.apply(go2name.get) results.sort_values(by=&#39;NES&#39;, ascending=False).head(10) . pathway pval padj log2err ES NES size leadingEdge go_name . 4 GO:0006367 | 0.022816 | 0.398352 | 0.352488 | 0.827233 | 1.444742 | 17 | VDR,NR3C1,CREBBP,CCN2,PGR,THRA | transcription initiation from RNA polymerase I... | . 7 GO:0006919 | 0.054000 | 0.398352 | 0.191892 | 0.742733 | 1.305878 | 21 | CDKN2A,NGFR,NGF,S100A9,EIF2AK3,NLRP1,BAD | activation of cysteine-type endopeptidase acti... | . 16 GO:0016579 | 0.048951 | 0.398352 | 0.202072 | 0.736472 | 1.299012 | 25 | CFTR,SMAD4,IL33,PTEN | protein deubiquitination | . 13 GO:0009749 | 0.090271 | 0.523571 | 0.145516 | 0.720428 | 1.263514 | 18 | SLC8A1,CCN2,ILDR2,GIPR,BAD,PTEN,NEUROD1,MAFA,R... | response to glucose | . 23 GO:0042593 | 0.054945 | 0.398352 | 0.190023 | 0.692868 | 1.233166 | 36 | NGFR,PDX1,BHLHA15,GCK,INS,LEP,GCGR,WFS1,LEPR,C... | glucose homeostasis | . 18 GO:0019722 | 0.186935 | 0.903518 | 0.095603 | 0.664942 | 1.161305 | 17 | CXCR2,CXCR1,BHLHA15,EIF2AK3,PDPK1,CHRM3 | calcium-mediated signaling | . 26 GO:0050821 | 0.226000 | 0.936286 | 0.084556 | 0.636343 | 1.118822 | 21 | CDKN2A,WFS1,PTEN,TP53,CDKN1A | protein stabilization | . 3 GO:0001666 | 0.280719 | 0.995976 | 0.073074 | 0.603386 | 1.073906 | 36 | SMAD4,CREBBP,LEP,TLR2,CD38 | response to hypoxia | . 15 GO:0016567 | 0.332000 | 0.995976 | 0.064794 | 0.600506 | 1.055813 | 21 | CUL4A,RBX1,CRBN,DDB1,FEM1B,SMURF1,CUL9,SOCS1,H... | protein ubiquitination | . 9 GO:0007204 | 0.412587 | 0.995976 | 0.054456 | 0.582426 | 1.027300 | 25 | CXCR2,CXCR1,CD38,PKD1,GIPR,FFAR1,GHRL,CCKBR,JA... | positive regulation of cytosolic calcium ion c... | . The ES plot for calcium signalling looks pretty similiar. . %%R plotEnrichment(pathways[[&quot;GO:0019722&quot;]], ranks) + labs(title=&quot;calcium-mediated signaling&quot;) . The fgsea package also have a gsea table plotting function. I don&#39;t think this really provides any additional information not shown in the pandas dataframe. The FDR for both packages is worryingly high. Perhaps this is due to either a very small geneset (there&#39;s only around ~600 goprocesses), or a relatively small number of genes with scores. Normally you would run prerank GSEA on the DEGs of a t&#39;omics comparison, and thus would have ~20,000 genes/score pairs. . %%R topPathwaysUp &lt;- old_results[ES &gt; 0][head(order(pval), n=10), pathway] topPathwaysDown &lt;- old_results[ES &lt; 0][head(order(pval), n=10), pathway] topPathways &lt;- c(topPathwaysUp, rev(topPathwaysDown)) plotGseaTable(pathways[topPathways], ranks, old_results, gseaParam=0.5) .",
            "url": "https://finlayiainmaclean.github.io/blog/useful_resources/2021/10/07/testable_processes.html",
            "relUrl": "/useful_resources/2021/10/07/testable_processes.html",
            "date": " • Oct 7, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://finlayiainmaclean.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://finlayiainmaclean.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}